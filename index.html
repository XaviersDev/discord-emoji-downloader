<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>discord multi-tool</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <style>
    :root {
      --background: 240 6% 10%;
      --foreground: 240 5% 95%;
      --muted: 240 4% 46%;
      --accent: 240 5% 26%;
      --accent-hover: 240 5% 36%;
      --primary: 262 83% 67%;
      --primary-hover: 262 83% 72%;
      --success: 142 76% 36%;
      --danger: 0 72% 51%;
      --border: 240 4% 20%;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: hsl(var(--background));
      color: hsl(var(--foreground));
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem;
      min-height: 100vh;
      margin: 0;
    }
    
    .container {
      width: 100%;
      max-width: 900px;
      padding: 1rem;
    }
    
    h1, h2, h3 {
      text-transform: lowercase;
      margin: 0 0 1rem 0;
      color: hsl(var(--primary));
      font-weight: 600;
      letter-spacing: 1px;
    }
    
    h1 { font-size: 2rem; text-align: center; }
    h2 { font-size: 1.5rem; border-bottom: 1px solid hsl(var(--border)); padding-bottom: 0.5rem; }
    
    input, select, button, textarea {
      width: 100%;
      margin: 0.5rem 0;
      padding: 0.75rem 1rem;
      border: 1px solid hsl(var(--border));
      border-radius: 8px;
      font-size: 1rem;
      background-color: hsl(var(--accent));
      color: hsl(var(--foreground));
      transition: all 0.2s ease;
      box-sizing: border-box;
    }
    
    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: hsl(var(--primary));
      box-shadow: 0 0 5px hsla(var(--primary), 0.5);
    }
    
    button {
      background-color: hsl(var(--primary));
      cursor: pointer;
      font-weight: bold;
    }
    
    button:hover:not(:disabled) {
      background-color: hsl(var(--primary-hover));
      transform: translateY(-2px);
    }
    
    button:disabled {
      background-color: hsl(var(--accent-hover));
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    textarea {
      min-height: 120px;
      resize: vertical;
    }
    
    .tabs { display: flex; flex-wrap: wrap; margin-bottom: 1rem; border-bottom: 2px solid hsl(var(--border)); }
    .tab-button {
      padding: 0.75rem 1.25rem;
      cursor: pointer;
      border: none;
      background: none;
      color: hsl(var(--muted));
      font-size: 1rem;
      border-bottom: 3px solid transparent;
      margin-bottom: -2px;
    }
    .tab-button.active {
      color: hsl(var(--primary));
      border-bottom-color: hsl(var(--primary));
    }
    
    .tab-content { display: none; }
    .tab-content.active { display: block; animation: fadeIn 0.5s; }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    #auth-section, #user-info {
      background: hsl(var(--accent), 0.2);
      border: 1px solid hsl(var(--border));
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }
    
    #user-info {
      flex-direction: row;
      justify-content: space-between;
    }
    .user-details { display: flex; align-items: center; gap: 1rem; }
    #user-avatar { width: 50px; height: 50px; border-radius: 50%; }
    
    #icons-preview, #emoji-preview {
      display: flex; flex-wrap: wrap; justify-content: center; margin-top: 1rem; gap: 1rem; max-height: 400px; overflow-y: auto; background: hsl(var(--background)); padding: 1rem; border-radius: 8px; border: 1px solid hsl(var(--border));
    }
    
    .icon-item { text-align: center; font-size: 0.85rem; }
    .icon-item img {
      width: 64px; height: 64px; border-radius: 10px; border: 2px solid hsl(var(--primary));
      background: hsl(var(--accent)); margin-bottom: 0.4rem;
    }
    
    #log {
      width: 100%;
      height: 200px;
      background-color: #111;
      border: 1px solid hsl(var(--border));
      border-radius: 8px;
      padding: 1rem;
      font-family: 'Courier New', Courier, monospace;
      white-space: pre-wrap;
      overflow-y: auto;
      margin-top: 1rem;
      color: #ccc;
      font-size: 0.9rem;
    }
    
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
    
    .progress-bar { width: 100%; background-color: hsl(var(--accent)); border-radius: 8px; overflow: hidden; height: 20px; }
    .progress-bar-fill {
      height: 100%;
      background-color: hsl(var(--success));
      width: 0%;
      transition: width 0.3s ease;
      text-align: center;
      line-height: 20px;
      font-size: 0.8rem;
    }
    
    .info-card { background: hsl(var(--accent), 0.3); padding: 1rem; border-radius: 8px; }
    .info-card h3 { color: hsl(var(--foreground)); font-size: 1.1rem; }
    
    #main-content { display: none; }
    
    .spinner {
      width: 24px;
      height: 24px;
      border: 3px solid hsl(var(--border));
      border-top-color: hsl(var(--primary));
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>discord multi-tool</h1>
    
    <div id="auth-section">
      <h2>авторизация</h2>
      <input type="password" id="token" placeholder="введите токен вашего аккаунта" />
      <button onclick="authorize()">войти</button>
      <div id="auth-log" style="color: hsl(var(--muted));"></div>
    </div>
    
    <div id="user-info" style="display: none;">
      <div class="user-details">
        <img id="user-avatar" src="" alt="avatar" />
        <div>
          <span id="username"></span>
          <div id="user-id" style="font-size: 0.8rem; color: hsl(var(--muted));"></div>
        </div>
      </div>
      <button onclick="logout()" style="width: auto; background-color: hsl(var(--danger));">выйти</button>
    </div>

    <div id="main-content">
      <div class="tabs">
        <button class="tab-button active" onclick="openTab(event, 'info-tab')">информация</button>
        <button class="tab-button" onclick="openTab(event, 'roles-tab')">иконки ролей</button>
        <button class="tab-button" onclick="openTab(event, 'emojis-tab')">эмодзи и стикеры</button>
        <button class="tab-button" onclick="openTab(event, 'clone-tab')">клонирование сервера</button>
        <button class="tab-button" onclick="openTab(event, 'webhook-tab')">вебхук</button>
      </div>

      <!-- вкладка: информация -->
      <div id="info-tab" class="tab-content active">
        <h2>информация о сервере</h2>
        <select id="guild-select-info" onchange="fetchGuildInfo()"></select>
        <div id="guild-info-display" style="margin-top: 1rem;"></div>
      </div>

      <!-- вкладка: иконки ролей -->
      <div id="roles-tab" class="tab-content">
        <h2>скачивание иконок ролей</h2>
        <select id="guild-select-roles"></select>
        <button onclick="fetchRoleIcons()">скачать иконки</button>
        <div id="icons-preview"></div>
        <div id="roles-log" class="log-area">—</div>
      </div>

      <!-- вкладка: эмодзи и стикеры -->
      <div id="emojis-tab" class="tab-content">
        <h2>скачивание эмодзи и стикеров</h2>
        <select id="guild-select-emojis"></select>
        <button onclick="fetchEmojisAndStickers()">скачать всё</button>
        <div id="emoji-preview"></div>
        <div id="emojis-log" class="log-area">—</div>
      </div>

      <!-- вкладка: клонирование -->
      <div id="clone-tab" class="tab-content">
        <h2>клонирование сервера</h2>
        <div class="grid-2">
            <input type="text" id="source-guild-id" placeholder="id сервера-источника" />
            <input type="text" id="target-guild-id" placeholder="id сервера-цели" />
        </div>
        <button id="clone-button" onclick="startCloning()">начать клонирование</button>
        <div id="clone-progress-bar" class="progress-bar" style="margin-top: 1rem;"><div id="clone-progress-fill" class="progress-bar-fill">0%</div></div>
        <div id="clone-log" class="log-area">—</div>
      </div>
      
      <!-- вкладка: вебхук -->
      <div id="webhook-tab" class="tab-content">
        <h2>отправка в вебхук</h2>
        <input type="text" id="webhook-url" placeholder="url вебхука" />
        <textarea id="webhook-message" placeholder="ваше сообщение"></textarea>
        <button onclick="sendWebhook()">отправить</button>
        <div id="webhook-log" class="log-area">—</div>
      </div>
    </div>
  </div>

  <script>
    let token = '';
    let guilds = [];
    let currentUser = null;

    document.addEventListener('DOMContentLoaded', () => {
        document.querySelectorAll('select').forEach(sel => sel.innerHTML = '<option>сначала войдите по токену</option>');
    });

    function openTab(evt, tabName) {
      document.querySelectorAll('.tab-content').forEach(tc => tc.style.display = 'none');
      document.querySelectorAll('.tab-button').forEach(tb => tb.classList.remove('active'));
      document.getElementById(tabName).style.display = 'block';
      evt.currentTarget.classList.add('active');
    }

    function log(tab, message) {
      const logEl = document.getElementById(`${tab}-log`);
      if (logEl) {
        logEl.textContent = message;
      }
    }

    async function authorize() {
        const tokenInput = document.getElementById('token');
        const authLog = document.getElementById('auth-log');
        
        if (!tokenInput.value.trim()) {
            authLog.textContent = 'ошибка: введите токен.';
            return;
        }

        token = tokenInput.value.trim();
        authLog.innerHTML = '<div class="spinner"></div>';

        try {
            const res = await fetch("https://discord.com/api/v10/users/@me", {
                headers: { Authorization: token }
            });

            if (!res.ok) {
                throw new Error(`неверный токен или ошибка сети: ${res.status}`);
            }

            currentUser = await res.json();
            
            document.getElementById('username').textContent = `${currentUser.username}#${currentUser.discriminator === '0' ? '' : currentUser.discriminator}`;
            document.getElementById('user-id').textContent = `id: ${currentUser.id}`;
            document.getElementById('user-avatar').src = currentUser.avatar 
                ? `https://cdn.discordapp.com/avatars/${currentUser.id}/${currentUser.avatar}.png` 
                : `https://cdn.discordapp.com/embed/avatars/${currentUser.discriminator % 5}.png`;

            document.getElementById('auth-section').style.display = 'none';
            document.getElementById('user-info').style.display = 'flex';
            document.getElementById('main-content').style.display = 'block';

            await loadGuilds();

        } catch (e) {
            authLog.textContent = `ошибка авторизации: ${e.message}`;
            token = '';
            currentUser = null;
        }
    }
    
    function logout() {
        token = '';
        guilds = [];
        currentUser = null;
        
        document.getElementById('token').value = '';
        document.getElementById('auth-log').textContent = '';
        document.getElementById('auth-section').style.display = 'flex';
        document.getElementById('user-info').style.display = 'none';
        document.getElementById('main-content').style.display = 'none';
        document.querySelectorAll('select').forEach(sel => sel.innerHTML = '<option>сначала войдите по токену</option>');
    }

    async function loadGuilds() {
      try {
        const res = await fetch("https://discord.com/api/v10/users/@me/guilds", {
          headers: { Authorization: token }
        });
        if (!res.ok) throw new Error(`ошибка при получении серверов: ${res.status}`);
        
        guilds = await res.json();
        const selects = document.querySelectorAll('select[id^="guild-select"]');
        
        selects.forEach(select => {
            select.innerHTML = "<option value=''>выберите сервер</option>";
            guilds.forEach(g => {
                const opt = document.createElement("option");
                opt.value = g.id;
                opt.textContent = g.name;
                select.appendChild(opt);
            });
        });
        
      } catch (e) {
        log('auth', `ошибка загрузки серверов: ${e.message}`);
      }
    }
    
    // --- вкладка: информация ---
    async function fetchGuildInfo() {
        const guildId = document.getElementById('guild-select-info').value;
        const display = document.getElementById('guild-info-display');
        if (!guildId) {
            display.innerHTML = '';
            return;
        }
        display.innerHTML = '<div class="spinner"></div>';
        try {
            const res = await fetch(`https://discord.com/api/v10/guilds/${guildId}?with_counts=true`, { headers: { Authorization: token }});
            if (!res.ok) throw new Error(`ошибка: ${res.status}`);
            const guild = await res.json();
            
            display.innerHTML = `
                <div class="info-card">
                    <h3>${guild.name}</h3>
                    <p>id: ${guild.id}</p>
                    <p>участников: ~${guild.approximate_member_count}</p>
                    <p>описание: ${guild.description || 'нет'}</p>
                    <p>особенности: ${guild.features.map(f => `\`${f.toLowerCase()}\``).join(', ')}</p>
                </div>
            `;
        } catch (e) {
            display.innerHTML = `<p style="color: hsl(var(--danger));">${e.message}</p>`;
        }
    }

    // --- вкладка: иконки ролей ---
    async function fetchRoleIcons() {
      const guildId = document.getElementById("guild-select-roles").value;
      if (!guildId) {
          log('roles', "пожалуйста, выберите сервер.");
          return;
      }
      const preview = document.getElementById("icons-preview");
      preview.innerHTML = "";
      log('roles', "загрузка ролей...");

      try {
        const res = await fetch(`https://discord.com/api/v10/guilds/${guildId}/roles`, {
          headers: { Authorization: token }
        });
        if (!res.ok) throw new Error(`ошибка получения ролей: ${res.status}`);
        
        const roles = await res.json();
        const zip = new JSZip();
        let count = 0;
        
        const iconRoles = roles.filter(role => role.icon);
        if (iconRoles.length === 0) {
            log('roles', "на этом сервере нет ролей с иконками.");
            return;
        }

        for (const role of iconRoles) {
            log('roles', `скачивание иконки для роли: ${role.name}...`);
            const url = `https://cdn.discordapp.com/role-icons/${role.id}/${role.icon}.png?size=128`;
            const imgRes = await fetch(url);
            if (!imgRes.ok) continue;
            
            const blob = await imgRes.blob();
            const cleanName = role.name.replace(/[^a-z0-9а-яё]/gi, '_').substring(0, 32) || 'role';
            zip.file(`${cleanName}_${role.id}.png`, blob);
            
            const imgURL = URL.createObjectURL(blob);
            preview.innerHTML += `<div class="icon-item"><img src="${imgURL}" alt="${cleanName}" /><div>${cleanName}</div></div>`;
            count++;
        }

        if (count === 0) {
          log('roles', "не удалось скачать ни одной иконки.");
          return;
        }
        
        const zipBlob = await zip.generateAsync({ type: "blob" });
        saveAs(zipBlob, `иконки_ролей_${guildId}.zip`);
        log('roles', `скачано ${count} иконок. архив сохранён.`);
      } catch (e) {
        log('roles', `ошибка: ${e.message}`);
      }
    }

    // --- вкладка: эмодзи и стикеры ---
    async function fetchEmojisAndStickers() {
        const guildId = document.getElementById("guild-select-emojis").value;
        if (!guildId) {
            log('emojis', "пожалуйста, выберите сервер.");
            return;
        }
        const preview = document.getElementById("emoji-preview");
        preview.innerHTML = "";
        log('emojis', "загрузка эмодзи и стикеров...");

        try {
            const [emojisRes, stickersRes] = await Promise.all([
                fetch(`https://discord.com/api/v10/guilds/${guildId}/emojis`, { headers: { Authorization: token } }),
                fetch(`https://discord.com/api/v10/guilds/${guildId}/stickers`, { headers: { Authorization: token } })
            ]);

            if (!emojisRes.ok && !stickersRes.ok) throw new Error('не удалось получить данные');
            
            const emojis = emojisRes.ok ? await emojisRes.json() : [];
            const stickers = stickersRes.ok ? await stickersRes.json() : [];
            
            if (emojis.length === 0 && stickers.length === 0) {
                log('emojis', "на сервере нет эмодзи или стикеров.");
                return;
            }

            const zip = new JSZip();
            let count = 0;

            for (const emoji of emojis) {
                const extension = emoji.animated ? 'gif' : 'png';
                const url = `https://cdn.discordapp.com/emojis/${emoji.id}.${extension}?size=128`;
                const res = await fetch(url);
                if (res.ok) {
                    const blob = await res.blob();
                    zip.folder('emojis').file(`${emoji.name}.${extension}`, blob);
                    const imgURL = URL.createObjectURL(blob);
                    preview.innerHTML += `<div class="icon-item"><img src="${imgURL}" alt="${emoji.name}"/><div>:${emoji.name}:</div></div>`;
                    count++;
                }
            }
            
            for (const sticker of stickers) {
                if (sticker.format_type === 3) continue; // lottie
                const extension = sticker.format_type === 1 ? 'png' : sticker.format_type === 2 ? 'apng' : 'png';
                const url = `https://cdn.discordapp.com/stickers/${sticker.id}.${extension}`;
                const res = await fetch(url);
                if (res.ok) {
                    const blob = await res.blob();
                    zip.folder('stickers').file(`${sticker.name}.${extension}`, blob);
                    const imgURL = URL.createObjectURL(blob);
                    preview.innerHTML += `<div class="icon-item"><img src="${imgURL}" alt="${sticker.name}"/><div>${sticker.name}</div></div>`;
                    count++;
                }
            }

            if (count === 0) {
                log('emojis', 'не удалось скачать файлы.');
                return;
            }

            const zipBlob = await zip.generateAsync({ type: "blob" });
            saveAs(zipBlob, `эмодзи_и_стикеры_${guildId}.zip`);
            log('emojis', `скачано ${count} файлов. архив сохранён.`);

        } catch (e) {
            log('emojis', `ошибка: ${e.message}`);
        }
    }

    // --- вкладка: клонирование ---
    let isCloning = false;
    const cloneLog = (message) => {
        const logEl = document.getElementById('clone-log');
        const timestamp = new Date().toLocaleTimeString();
        logEl.innerHTML += `[${timestamp}] ${message}\n`;
        logEl.scrollTop = logEl.scrollHeight;
    };
    const updateProgress = (percentage) => {
        const fill = document.getElementById('clone-progress-fill');
        fill.style.width = `${percentage}%`;
        fill.textContent = `${Math.round(percentage)}%`;
    };

    async function apiRequest(endpoint, options = {}) {
        const defaultHeaders = { 'Authorization': token, 'Content-Type': 'application/json' };
        options.headers = { ...defaultHeaders, ...options.headers };
        
        await new Promise(res => setTimeout(res, 550)); // базовый rate limit
        
        const response = await fetch(`https://discord.com/api/v10/${endpoint}`, options);
        if (!response.ok) {
            if (response.status === 429) {
                const retryAfter = (await response.json()).retry_after || 1;
                cloneLog(`⚠️ rate limit. ожидание ${retryAfter}с...`);
                await new Promise(res => setTimeout(res, retryAfter * 1000 + 500));
                return apiRequest(endpoint, options);
            }
            const errorData = await response.json().catch(() => ({ message: 'неизвестная ошибка' }));
            throw new Error(`ошибка api (${response.status}): ${errorData.message || 'нет сообщения'}`);
        }
        if (response.status === 204) return null;
        return response.json();
    }

    async function startCloning() {
        if (isCloning) return;
        isCloning = true;
        document.getElementById('clone-button').disabled = true;
        document.getElementById('clone-log').innerHTML = '';
        updateProgress(0);

        const sourceId = document.getElementById('source-guild-id').value.trim();
        const targetId = document.getElementById('target-guild-id').value.trim();

        if (!sourceId || !targetId) {
            cloneLog("❌ ошибка: укажите id исходного и целевого сервера.");
            isCloning = false;
            document.getElementById('clone-button').disabled = false;
            return;
        }

        try {
            cloneLog("🚀 начало процесса клонирования...");
            updateProgress(5);

            // 1. получение данных
            cloneLog(" fetching source server data...");
            const [sourceGuild, sourceChannels, sourceRoles] = await Promise.all([
                apiRequest(`guilds/${sourceId}`),
                apiRequest(`guilds/${sourceId}/channels`),
                apiRequest(`guilds/${sourceId}/roles`)
            ]);
            cloneLog(`✅ получены данные с сервера "${sourceGuild.name}"`);
            updateProgress(15);
            
            // 2. очистка целевого сервера
            cloneLog("🧹 очистка целевого сервера...");
            const targetChannels = await apiRequest(`guilds/${targetId}/channels`);
            for (const channel of targetChannels) {
                await apiRequest(`channels/${channel.id}`, { method: 'DELETE' });
                cloneLog(`  - удалён канал: ${channel.name}`);
            }
            const targetRoles = (await apiRequest(`guilds/${targetId}/roles`)).filter(r => !r.managed && r.name !== '@everyone');
            for (const role of targetRoles) {
                await apiRequest(`guilds/${targetId}/roles/${role.id}`, { method: 'DELETE' });
                cloneLog(`  - удалена роль: ${role.name}`);
            }
            cloneLog("✅ целевой сервер очищен.");
            updateProgress(30);

            // 3. клонирование настроек сервера
            cloneLog("⚙️ клонирование настроек сервера...");
            await apiRequest(`guilds/${targetId}`, {
                method: 'PATCH',
                body: JSON.stringify({
                    name: `${sourceGuild.name} (копия)`,
                    icon: sourceGuild.icon,
                    description: sourceGuild.description,
                })
            });
            cloneLog("✅ настройки сервера обновлены.");
            updateProgress(40);

            // 4. клонирование ролей
            cloneLog("🎨 клонирование ролей...");
            const roleIdMap = new Map();
            const sortedRoles = sourceRoles.filter(r => !r.managed && r.name !== '@everyone').sort((a, b) => b.position - a.position);
            for (const role of sortedRoles) {
                const newRole = await apiRequest(`guilds/${targetId}/roles`, {
                    method: 'POST',
                    body: JSON.stringify({
                        name: role.name,
                        permissions: role.permissions,
                        color: role.color,
                        hoist: role.hoist,
                        mentionable: role.mentionable,
                        icon: role.icon,
                        unicode_emoji: role.unicode_emoji
                    })
                });
                roleIdMap.set(role.id, newRole.id);
                cloneLog(`  - создана роль: ${role.name}`);
            }
            cloneLog("✅ роли созданы.");
            updateProgress(60);

            // 5. клонирование каналов
            cloneLog("📁 клонирование каналов и категорий...");
            const channelIdMap = new Map();
            const categories = sourceChannels.filter(c => c.type === 4).sort((a, b) => a.position - b.position);
            const channels = sourceChannels.filter(c => c.type !== 4).sort((a, b) => a.position - b.position);

            for (const category of categories) {
                const newCategoryData = {
                    name: category.name,
                    type: category.type,
                    permission_overwrites: category.permission_overwrites.map(p => ({
                        ...p,
                        id: p.id === sourceId ? targetId : roleIdMap.get(p.id) || p.id
                    }))
                };
                const newCategory = await apiRequest(`guilds/${targetId}/channels`, {
                    method: 'POST',
                    body: JSON.stringify(newCategoryData)
                });
                channelIdMap.set(category.id, newCategory.id);
                cloneLog(`  - создана категория: ${category.name}`);
            }
            
            for (const channel of channels) {
                const newChannelData = {
                    name: channel.name,
                    type: channel.type,
                    topic: channel.topic,
                    nsfw: channel.nsfw,
                    rate_limit_per_user: channel.rate_limit_per_user,
                    bitrate: channel.bitrate,
                    user_limit: channel.user_limit,
                    parent_id: channel.parent_id ? channelIdMap.get(channel.parent_id) : null,
                    permission_overwrites: channel.permission_overwrites.map(p => ({
                        ...p,
                        id: p.id === sourceId ? targetId : roleIdMap.get(p.id) || p.id
                    }))
                };
                await apiRequest(`guilds/${targetId}/channels`, {
                    method: 'POST',
                    body: JSON.stringify(newChannelData)
                });
                cloneLog(`  - создан канал: ${channel.name}`);
            }
            cloneLog("✅ каналы созданы.");
            updateProgress(90);

            // 6. клонирование эмодзи и стикеров
            cloneLog("😀 клонирование эмодзи и стикеров...");
            const sourceEmojis = await apiRequest(`guilds/${sourceId}/emojis`);
            for (const emoji of sourceEmojis) {
                const res = await fetch(`https://cdn.discordapp.com/emojis/${emoji.id}.${emoji.animated ? 'gif' : 'png'}`);
                const blob = await res.blob();
                const reader = new FileReader();
                reader.readAsDataURL(blob);
                reader.onloadend = async () => {
                    const base64data = reader.result;
                    await apiRequest(`guilds/${targetId}/emojis`, {
                        method: 'POST',
                        body: JSON.stringify({
                            name: emoji.name,
                            image: base64data,
                        })
                    });
                    cloneLog(`  - создан эмодзи: ${emoji.name}`);
                };
            }
            cloneLog("✅ эмодзи и стикеры скопированы.");
            updateProgress(100);

            cloneLog("🎉 клонирование сервера успешно завершено!");

        } catch (e) {
            cloneLog(`❌ критическая ошибка: ${e.message}\n${e.stack}`);
        } finally {
            isCloning = false;
            document.getElementById('clone-button').disabled = false;
        }
    }
    
    async function sendWebhook() {
        const url = document.getElementById('webhook-url').value.trim();
        const message = document.getElementById('webhook-message').value;
        if (!url || !message) {
            log('webhook', 'ошибка: введите url и сообщение.');
            return;
        }
        log('webhook', 'отправка...');
        try {
            const res = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ content: message })
            });
            if (!res.ok) {
                throw new Error(`ошибка отправки: ${res.status}`);
            }
            log('webhook', 'сообщение успешно отправлено!');
        } catch(e) {
            log('webhook', `ошибка: ${e.message}`);
        }
    }

  </script>
</body>
</html>
